Here’s a **structured view of the problems I’ve solved**, organized by **data structure/technique**:

---

### **1. List-Based Problems**

* Sum of a list → simple iteration
* Largest in a list → iteration and comparison
* Sum of even numbers → conditional sum
* Count odd numbers → conditional count
* Second largest in a list → tracking two variables
* Merge two sorted lists → two-pointer technique
* Rotate a list by k positions → slicing / list operations

---

### **2. String-Based Problems**

* Count vowels → string iteration
* Reverse a string → indexing / slicing
* Check if prime → numeric operations, iteration
* Factorial → numeric operations, loop
* Check palindrome → string normalization & comparison
* Count frequency of characters → dictionary for counting
* Check anagram → dictionary frequency comparison

---

### **3. Set-Based / Hashing Problems**

* Find duplicates → set for fast membership check
* Sum pairs → set for O(1) lookup
* Remove duplicates from a list → set for O(1) insertion
* Longest consecutive subsequence → set + sequence detection

---

### **4. Dictionary-Based / Frequency Counting**

* Count characters in string → dict for frequency
* Anagram problem → dict for frequency comparison

---

### **5. Technique Highlights**

* **Two-pointer** → merge two sorted lists, sum pairs
* **One-pass solution** → counting characters, sum pairs
* **Hashing / sets** → duplicates, sum pairs, longest consecutive subsequence

---

This layout shows:

* My **strong grasp of lists, sets, and dictionaries**.
* I’ve also touched **two-pointer and hashing techniques**.
* I haven’t yet covered **stacks, queues, linked lists**, or **graph/tree structures**, which would be next.

---

## **What next?**

### 1. **Move to Stacks and Queues**

* You said earlier you weren’t ready; now it’s the perfect time.
* Implement **stack and queue problems** in Python using **lists and `collections.deque`**.
* Key concepts: LIFO (stack), FIFO (queue), `push/pop`, `enqueue/dequeue`.
* Example problems:

  * Valid parentheses
  * Next greater element
  * Sliding window max (queue-based)

---

### 2. **Practice Two-Pointer / Sliding Window Problems**

* You’ve seen the two-pointer idea in merging lists and pair sum problems.
* Start solving **subarray/subsequence problems** using this technique.
* Examples:

  * Maximum sum subarray of size k
  * Two sum (already did)
  * Trapping rainwater (medium level)

---

### 3. **Hashing / Frequency Counting**

* You’ve done anagram, duplicates, and character counts.
* Next, combine hashing with other structures:

  * Longest substring without repeating characters
  * Subarray with sum = k
  * Count pairs with given difference

---

### 4. **Start Light DSA Concepts**

* **Linked lists, stacks, queues (custom classes)**: implement from scratch.
* This helps when interviewers ask “implement stack using linked list” or similar.
* You don’t need full OS-level memory detail yet — focus on structure and operations.

---

### 5. **Time Complexity Awareness**

* Start **annotating your solutions** with:

  * `O(n)`, `O(n^2)`, or O(1) operations.
* This will build intuition before moving to harder problems.

---

### 6. **Consistency**

* Solve **1-2 problems per day** and vary difficulty: easy → medium → combination.
* Track the **data structure used**, so you learn when to use list vs set vs dict vs deque.
